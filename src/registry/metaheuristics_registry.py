import json
from src.core import logger
from src.integrations.external_api_calls import call_llm_api, call_osm_api
from src.registry import process_registry


class MetaHeuristic:
    def __init__(self, name, steps, metadata):
        self.name = name
        self.steps = steps  # Список шагов (процессов, условий, ветвлений)
        self.metadata = metadata  # Подробное описание
        self.generated_pipelines = []
    
    def generate_pipeline(self, df):
        """
        Analyze the data and generate a new pipeline configuration.
        """
        logger.info(f"Generating pipeline using metaheuristic: {self.name}")

        # Пример: Генерация пайплайна для обработки выбросов
        pipeline = {
            "name": f"generated_pipeline_{self.name}",
            "description": "Pipeline generated by metaheuristic.",
            "steps": [
                {"type": "process", "name": "Detect Outliers"},
                {"type": "process", "name": "Remove Outliers"},
                {"type": "process", "name": "Normalize Numeric Columns"}
            ]
        }
        self.generated_pipelines.append(pipeline)
        return pipeline

    def save_pipeline(self, pipeline, save_path="pipelines/"):
        """
        Save the generated pipeline as a JSON file.
        """
        import os
        os.makedirs(save_path, exist_ok=True)
        pipeline_name = pipeline["name"]
        with open(f"{save_path}/{pipeline_name}.json", "w") as f:
            json.dump(pipeline, f, indent=4)
        logger.info(f"Pipeline {pipeline_name} saved to {save_path}")
        
    def execute(self, df, context=None):
        """
        Выполняет шаги метаэвристики.
        :param df: DataFrame для обработки.
        :param context: Дополнительный контекст выполнения (например, внешние данные).
        """
        for step in self.steps:
            if step["type"] == "process":
                process_name = step["name"]
                parameters = step.get("parameters", {})
                df = process_registry.execute(process_name, df, **parameters)
            elif step["type"] == "condition":
                condition = step["condition"]
                if not eval(condition):
                    break  # Остановить выполнение, если условие не выполнено
            elif step["type"] == "external_call":
                df = self._handle_external_call(df, step)
            elif step["type"] == "branch":
                branch = step["branches"]
                for branch_condition, branch_steps in branch.items():
                    if eval(branch_condition):
                        for branch_step in branch_steps:
                            df = self._execute_step(df, branch_step)
        return df

    def _handle_external_call(self, df, step):
        """
        Обрабатывает внешние вызовы, такие как API или LLM.
        """
        if step["api"] == "osm":
            # Пример вызова OpenStreetMap API
            df = call_osm_api(df, step["parameters"])
        elif step["api"] == "llm":
            # Пример вызова LLM через OpenAI API
            response = call_llm_api(step["parameters"]["prompt"])
            df[step["parameters"]["output_column"]] = response
        return df

    def _execute_step(self, df, step):
        """Обрабатывает один шаг метаэвристики."""
        if step["type"] == "process":
            return process_registry.execute(step["name"], df, **step.get("parameters", {}))
        return df

class MetaHeuristicsRegistry:
    def __init__(self):
        self.registry = {}

    def register(self, name, heuristic, metadata):
        """
        Регистрирует метаэвристику.
        :param name: Имя метаэвристики.
        :param heuristic: Объект MetaHeuristic.
        :param metadata: Метаданные метаэвристики.
        """
        if name in self.registry:
            logger.warning(f"MetaHeuristic {name} is already registered. Overwriting.")
        self.registry[name] = {"heuristic": heuristic, "metadata": metadata}

    def execute(self, name, df, context=None):
        """
        Выполняет зарегистрированную метаэвристику.
        :param name: Имя метаэвристики.
        :param df: DataFrame для обработки.
        :param context: Дополнительный контекст.
        """
        if name not in self.registry:
            logger.error(f"MetaHeuristic {name} not found.")
            return None
        heuristic = self.registry[name]["heuristic"]
        return heuristic.execute(df, context)
